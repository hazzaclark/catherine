// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS
//
// SPECIFICALLY, FOCUSSING ON THE INHERITANCE METHODS OF CREATING AN INSTRUCTION BASE
// TYPE FOR THE CURRENT WORD AND ADDRESS

#ifndef CATH_INSTR_SH2_BASE_HPP
#define CATH_INSTR_SH2_BASE_HPP

#pragma once 

// NESTED INCLUDES

#include "instructions/instruction.hpp"

namespace catherine
{    
    using CATH_INSTR_DIR = catherine::CATH_INSTR_ID_CXX;


    class CATH_INSTRUCTION_SH2 : public CATH_INSTRUCTION
    {
        public:
            CATH_INSTRUCTION_SH2(U16 WORD, U32 ADDRESS);
            virtual ~CATH_INSTRUCTION_SH2() = default;
    };

    // HELPER FUNCTIONS MOSTLY TO DO WITH ACCESSING SPECIFIC
    // INSTRUCTION TYPES - SOME NECESSARY FOR THE RECOMPILED BLOCKS

    inline bool CATH_INSTR_IS_RTS(const CATH_INSTRUCTION& INSTR)
    { 
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_RTS;
    }

    inline bool CATH_INSTR_IS_RTE(const CATH_INSTRUCTION& INSTR)
    { 
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_RTE;
    }

    inline bool CATH_INSTR_IS_MOVA(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_MOVA;
    }
    
    inline bool CATH_INSTR_IS_BRANCH(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->IS_BRANCH;
    }

    inline bool CATH_INSTR_IS_JMP(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->IS_JUMP;
    }

    inline bool CATH_INSTR_HAS_DELAY_SLOT(const CATH_INSTRUCTION& INSTR) 
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->HAS_DELAY_SLOT;
    }

    inline bool CATH_INSTR_IS_JUMP_ADDRESS(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->IS_JUMP_ADDRESS;
    }

    inline bool CATH_INSTR_IS_FUNCTION_CALL(const CATH_INSTRUCTION& INSTR)
    {
        CATH_INSTR_DIR ID = INSTR.CATH_GET_UNIQUE_ID();
        return (ID == CATH_INSTR_DIR::CATH_INSTR_ID_BSR     || 
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_BSRF    ||
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_JSR);
    }

    inline bool CATH_INSTR_IS_INDIRECT_JMP(const CATH_INSTRUCTION& INSTR)
    {
        CATH_INSTR_DIR ID = INSTR.CATH_GET_UNIQUE_ID();
        return (ID == CATH_INSTR_DIR::CATH_INSTR_ID_JMP     ||
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_BRAF); 
    }
}

#endif
