// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE OPERAND
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE OPERANDS
//
// MORE SPECIFICALLY, THIS FILE ACCESSES ALL OF THE OPERAND FUNCTION CALLS
// AND TYPES, ACCESSES THE CURRENT STRING LITERAL OF THE OPERAND
// AND RETURNS ACCORDINGLY

// NESTED INCLUDES

#include "instructions/operands.h"
#include "instructions/instruction.h"
#include "instructions/register.h"
#include "tables/tables.h"

UNK CATH_OPERAND_TYPE_NONE(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    (void)BUFFER;
    (void)SIZE;
    return 0;
}

UNK CATH_OPERAND_TYPE_RM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    return snprintf(BUFFER, SIZE, "%s", CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_RN(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "%s", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_R0(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "R0");
}

UNK CATH_OPERAND_TYPE_IMM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    S32 IMM = CATH_INSTRUCTION_GET_IMM(INSTR);
    
    // TRAPA USES UNSIGNED IMMEDIATE
    // HANDLE FOR SUCH A CASE
    if(INSTR->INSTR_ID == CATH_INSTR_ID_TRAPA)
    {
        return snprintf(BUFFER, SIZE, "#0x%X", (U8)IMM);
    }

    return snprintf(BUFFER, SIZE, "#0x%X", (U32)IMM);
}

UNK CATH_OPERAND_TYPE_AT_RN(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "@%s", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_AT_RM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    return snprintf(BUFFER, SIZE, "@%s", CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_AT_RM_POST_INC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    return snprintf(BUFFER, SIZE, "@%s+", CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_AT_RN_PRE_DEC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "@-%s", CATH_REGISTER_GET_GPRNAME(RN));
}
UNK CATH_OPERAND_TYPE_AT_RN_POST_INC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "@%s+", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_AT_R0_RN(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "@(R0, %s)", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_AT_R0_RM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    return snprintf(BUFFER, SIZE, "@(R0, %s)", CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_AT_DISP_GBR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 DISP = CATH_INSTRUCTION_GET_DISP(INSTR);
    return snprintf(BUFFER, SIZE, "@(#0x%X, GBR)", DISP);
}

UNK CATH_OPERAND_TYPE_AT_RN_PC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "@(%s, PC)", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_AT_R0_GBR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "@(R0, GBR)");
}

UNK CATH_OPERAND_TYPE_AT_DISP_PC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    S32 DISP = CATH_INSTRUCTION_GET_DISP(INSTR);
    U32 PC = CATH_GET_PC(INSTR);
    U32 ALIGNED;

    // DETERMINE THE ALIGNMENT BASED ON INSTRUCTION SIZE
    switch(INSTR->INSTR_ID)
    {
        case CATH_INSTR_ID_MOVLLP:
        case CATH_INSTR_ID_MOVA:
            ALIGNED = SH2_LONG_ALIGN(PC);
            break;

        case CATH_INSTR_ID_MOVWLP:
            ALIGNED = SH2_WORD_ALIGN(PC);
            break;

        default:
            ALIGNED = SH2_BYTE_ALIGN(PC);
            break;
    }

    U32 EA = ALIGNED + DISP;
    return snprintf(BUFFER, SIZE, "@(#0x%X)", EA);
}

UNK CATH_OPERAND_TYPE_DISP_PC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    S32 DISP = CATH_INSTRUCTION_GET_DISP(INSTR);
    U32 PC = CATH_GET_PC(INSTR);
    U32 TARGET = PC + 4 + DISP;
    return snprintf(BUFFER, SIZE, "0x%08X", TARGET);
}

UNK CATH_OPERAND_TYPE_AT_DISP_RN(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN;
    
    // SOME INSTRUCTIONS DO REQUIRE THAT LITTLE EXTRA
    // DISCERNMENT WHEN ACCOUNTING FOR THE LOWEST BITS OF AN INSTRUCTION
    //
    // APTLY ACCOUNT FOR THAT BY ACCESSING BITS 7-4 FOR
    // THOSE SPECIAL CASES

    switch(INSTR->INSTR_ID)
    {
        case CATH_INSTR_ID_MOVBS4:
        case CATH_INSTR_ID_MOVWS4:
        case CATH_INSTR_ID_MOVBL4:
        case CATH_INSTR_ID_MOVWL4:
            RN = CATH_SHIFT_R(INSTR->WORD, 4, 4); 
            break;
            
        default:
            RN = SH2_INSTR_GET_RN(INSTR);
            break;
    }
    
    U8 DISP = SH2_INSTR_GET_DISP4(INSTR);
    U32 SCALE = CATH_DISP_SCALE[INSTR->INSTR_ID];
    U32 SCALED_DISP = DISP * SCALE;
    
    return snprintf(BUFFER, SIZE, "@(0x%X, %s)", SCALED_DISP, CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_AT_DISP_RM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    U8 DISP = SH2_INSTR_GET_DISP4(INSTR);

    U32 SCALE = CATH_DISP_SCALE[INSTR->INSTR_ID];
    U32 SCALED_DISP = DISP * SCALE;
    return snprintf(BUFFER, SIZE, "@(0x%X, %s)", SCALED_DISP, CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_AT_IMM_RN_RM(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    S32 IMM = CATH_INSTRUCTION_GET_IMM(INSTR);

    return snprintf(BUFFER, SIZE, "@(#0x%X, %s, %s)",
                    (U32)IMM,
                    CATH_REGISTER_GET_GPRNAME(RN),
                    CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_RN_PC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RN = SH2_INSTR_GET_RN(INSTR);
    return snprintf(BUFFER, SIZE, "%s+PC", CATH_REGISTER_GET_GPRNAME(RN));
}

UNK CATH_OPERAND_TYPE_RM_PC(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 RM = SH2_INSTR_GET_RM(INSTR);
    return snprintf(BUFFER, SIZE, "%s+PC", CATH_REGISTER_GET_GPRNAME(RM));
}

UNK CATH_OPERAND_TYPE_AT_DISP_PC_ALIGN(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    U8 DISP = SH2_INSTR_GET_DISP8(INSTR);
    // LOAD RELATIVE PC ADDRESS BASED ON ALIGNED BOUNDS
    U32 ADDRESS = CATH_GET_PC(INSTR);
    U32 ALIGNED = (ADDRESS + 4) & ~3;

    U32 SCALE = CATH_DISP_SCALE[INSTR->INSTR_ID];
    U32 EA = ALIGNED + (DISP * SCALE);

    return snprintf(BUFFER, SIZE, "@(0x%X, PC)", EA);
}

UNK CATH_OPERAND_TYPE_SR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "SR");
}

UNK CATH_OPERAND_TYPE_GBR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "GBR");
}

UNK CATH_OPERAND_TYPE_VBR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "VBR");
}

UNK CATH_OPERAND_TYPE_MACH(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "MACH");
}

UNK CATH_OPERAND_TYPE_MACL(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "MACL");
}

UNK CATH_OPERAND_TYPE_PR(const SH_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    return snprintf(BUFFER, SIZE, "PR");
}
