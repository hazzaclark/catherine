// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE OPERAND
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE DSP OPERANDS

// NESTED INCLUDES

#include "instructions/instructionDSP.h"
#include "instructions/operandsDSP.h"

// ACCESS THE CURRENT BUFFER SIZE FOR EACH DSP OPERAND
// FOLLOW THE SAME DESIGN PATTERN OF THE BASE OPERAND DEFINTION
UNK CATH_DSP_OPERAND_TYPE_GET_BUFFER_SIZE(SH_DSP_OPERAND_TYPE TYPE, const SH_DSP_INSTRUCTION* INSTR)
{
    // ASSIGN THE CALLBACK TO EACH RESPECTIVE TYPE
    SH_DSP_OPERAND_CALLBACK CB;
    CB = DSP_INSTR_CALLBACKS[TYPE];
    
    return CB(INSTR, NULL, 0);
}

UNK CATH_DSP_OPERAND_TYPE_DISASM(SH_DSP_OPERAND_TYPE TYPE, const struct SH_DSP_INSTRUCTION* INSTR, char* DEST)
{
    SH_DSP_OPERAND_CALLBACK CB;
    CB = DSP_INSTR_CALLBACKS[TYPE];
    
    return CB(INSTR, DEST, 64);
}

// DETERMINES ALL OF THE CONURRENT OPERANDS AND APPLIES
// THEM TO THE BUFFER
//
// A SIMILAR DESIGN PATTERN TO THE BASE DISASM OPERAND DEFINITION IS REUSED
// ALBEIT ONLY USED FOR TRACKING PARALLELISED INSTRUCTIONS 
UNK CATH_DSP_INSTRUCTION_DISASM_OPERAND(const SH_DSP_INSTRUCTION* INSTR, char* DEST)
{
    UNK TOTAL_SIZE = 0;
    UNK SLOT_COUNT = 0;
    bool HAS_OPERATION = false;

    // DETERMINE THE CURRENTLY USED SLOTS WITHIN THE DSP ITSELF
    // HELPS WITH DETERMINING THE CONDITIONS OF EACH RESPECTIVE "NTH_BUS"

    const SH_DSP_DESCRIPTOR* DSP_DESC = INSTR->DESCRIPTOR;
    SH_DSP_PARALLEL_SLOT DSP_SLOTS[5];
    
    // CHECK FOR SPECICAL CASES BEFORE THE DEFINITION OF 
    // BUS LOCATION - HELPS WITH UNDERSTANDING THE LENGTH
    // OF THE OPCODE 

    if(DSP_DESC->IS_END) return snprintf(DEST, 64, "ENDI");
    if(DSP_DESC->IS_NOP) return snprintf(DEST, 64, "NOP");

    CATH_DSP_BUILD_SLOT_TABLE(DSP_DESC);

    // ITERATE THROUGH ALL AVAILABLE PARALLEL SLOTS
    // SKIP INACTIVE SLOTS ASSUMING A NOP
    for(UNK INDEX = 0; INDEX < SLOT_COUNT; INDEX++)
    {
        const SH_DSP_PARALLEL_SLOT* SLOT = &DSP_SLOTS[INDEX];

        if(INDEX > 0)
        {
            DEST[TOTAL_SIZE++] = ' ';
            DEST[TOTAL_SIZE++] = ' ';
        }

        // ACCESS THE NAME OF THE OPERAND BASED ON SLOT CHARACTERISTICS
        if(SLOT->IS_ALU)
        {
            const char* INSTR_NAME = CATH_DSP_INSTR_ID_NAMES[INSTR->INSTR_ID];
            TOTAL_SIZE += snprintf(DEST + TOTAL_SIZE, 64, "$s", INSTR_NAME);
        }

        else
        {
            DEST[TOTAL_SIZE++] = ',';
            TOTAL_SIZE += snprintf(DEST + TOTAL_SIZE, 64, "%s", SLOT->DEST_NAME);
        }
    }
    
    return TOTAL_SIZE;
}

UNK CATH_DSP_OPERAND_TYPE_NONE(const struct SH_DSP_INSTRUCTION* INSTR, char* BUFFER, UNK SIZE)
{
    (void)INSTR;
    (void)BUFFER;
    (void)SIZE;
    return 0;
}
