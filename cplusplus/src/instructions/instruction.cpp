// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS

// NESTED INCLUDES

#include "enums/instructions.hpp"
#include "instructions/instruction.hpp"
#include "instructions/instruction_sh2.hpp"

// SYSTEM INCLUDES

#include <cstring>
#include <cstdlib>

using namespace catherine;

// THE FOLLOWING CONSTRUCTOR HELPS WITH A SPECIFIC OP
// FOCUSSES ON ACCESSING THE CURRENT WORD AND PC ADDRESS FOR EACH
//
// ALWAYS USE &this FOR ACCESSING THE REFERENCE ASSOCIATED WITH THE CLASS
CATH_INSTRUCTION_SH2::CATH_INSTRUCTION_SH2(U16 WORD, U32 PC) : CATH_INSTRUCTION() 
{
    std::memset(&this->INSTR, 0, sizeof(SH_INSTRUCTION));
    CATH_INSTRUCTION_INIT(&this->INSTR, WORD, PC);
    CATH_INSTRUCTION_PROCESS(&this->INSTR);
}

// NOW WE CAN FOCUS ON THE IMPLEMENTATION OF MAKING C++ WRAPPERS
// FOR THE C API LOGIC 
//
// WHEN ACCESSING THESE METHODS, WE CAN FORMAT THE STRINGS USING "c_str()"

std::string CATH_INSTRUCTION::CATH_DISASSEMBLE_OPERANDS() const
{
    char BUFFER[256];
    CATH_INSTRUCTION_DISASM_OPERAND(&this->INSTR, BUFFER);
    return std::string(BUFFER);
}

std::string CATH_INSTRUCTION::CATH_DISASSEMBLE_INSTR() const
{
    char BUFFER[256];
    CATH_INSTRUCTION_DISASM_INSTR(&this->INSTR, BUFFER);
    return std::string(BUFFER);
}

std::string CATH_INSTRUCTION::CATH_DISASSEMBLE_DATA() const
{
    char BUFFER[256];
    CATH_INSTRUCTION_DISASM_DATA(&this->INSTR, BUFFER);
    return std::string(BUFFER);
}

std::string CATH_INSTRUCTION::CATH_DISASSEMBLE() const
{
    char BUFFER[256];
    CATH_INSTRUCTION_DISASM(&this->INSTR, BUFFER);
    return std::string(BUFFER);
}
