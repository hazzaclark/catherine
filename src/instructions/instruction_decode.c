// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY ENCOMPASSING THE LOOKUP TABLE
// FOR INSTRUCTION DECODING
//
// SUCH IMPLEMENTATION WAS THE ONLY WAY I SOUGHT TO IMPLEMENT AN EASE OF USE MEANS OF LOOKING
// UP CORRESPONDENCES AGAINST THEIR ENUM VALUE AND DESCRIPTOR IDENTIFIER

// NESTED INCLUDES

#include "instructions/instruction.h"

// DEFIE THE BASIS BY WHICH WE ARE ABLE TO LOOKUP ENTRIES WITHIN THE TABLE

// FROM THERE, GENERATE THE LOOKUP TABLE BASED ON THE ABOVE CORRESSPONDENCE
static const SH_ENTRY SH2_DECODE_TABLE[CATH_INSTR_ID_ALL_MAX] =
{
    // VERBATIM MATCHES (FULL WORD-WISE OPERATIONS)
    { 0xFFFF, 0x0009, CATH_INSTR_ID_NOP },
    { 0xFFFF, 0x000B, CATH_INSTR_ID_RTS },
    { 0xFFFF, 0x0008, CATH_INSTR_ID_CLRT },
    { 0xFFFF, 0x0018, CATH_INSTR_ID_SETT },
    { 0xFFFF, 0x001B, CATH_INSTR_ID_SLEEP },
    { 0xFFFF, 0x0028, CATH_INSTR_ID_CLRMAC },
    { 0xFFFF, 0x002B, CATH_INSTR_ID_RTE },
    { 0xFFFF, 0x0019, CATH_INSTR_ID_DIV0U },
    
    // 0000 nnnn mmmm xxxx
    { 0xF00F, 0x0003, CATH_INSTR_ID_BSRF },
    { 0xF00F, 0x0023, CATH_INSTR_ID_BRAF },
    { 0xF0FF, 0x000A, CATH_INSTR_ID_STSMACH },
    { 0xF0FF, 0x001A, CATH_INSTR_ID_STSMACL },
    { 0xF0FF, 0x002A, CATH_INSTR_ID_STSPR },
    { 0xF0FF, 0x0002, CATH_INSTR_ID_STCSR },
    { 0xF0FF, 0x0012, CATH_INSTR_ID_STCGBR },
    { 0xF0FF, 0x0022, CATH_INSTR_ID_STCVBR },
    { 0xF00F, 0x0004, CATH_INSTR_ID_MOVBS0 },
    { 0xF00F, 0x0005, CATH_INSTR_ID_MOVWS0 },
    { 0xF00F, 0x0006, CATH_INSTR_ID_MOVLS0 },
    { 0xF00F, 0x0007, CATH_INSTR_ID_MUL },
    { 0xF00F, 0x000C, CATH_INSTR_ID_MOVBL0 },
    { 0xF00F, 0x000D, CATH_INSTR_ID_MOVWL0 },
    { 0xF00F, 0x000E, CATH_INSTR_ID_MOVLL0 },
    { 0xF00F, 0x000F, CATH_INSTR_ID_MACL },
    { 0xF00F, 0x400F, CATH_INSTR_ID_MACW },
    
    // 0001 nnnn mmmm dddd
    { 0xF000, 0x1000, CATH_INSTR_ID_MOVLS4 },
    
    // 0010 nnnn mmmm xxxx
    { 0xF00F, 0x2000, CATH_INSTR_ID_MOVBS },
    { 0xF00F, 0x2001, CATH_INSTR_ID_MOVWS },
    { 0xF00F, 0x2002, CATH_INSTR_ID_MOVLS },
    { 0xF00F, 0x2004, CATH_INSTR_ID_MOVBM },
    { 0xF00F, 0x2005, CATH_INSTR_ID_MOVWM },
    { 0xF00F, 0x2006, CATH_INSTR_ID_MOVLM },
    { 0xF00F, 0x2007, CATH_INSTR_ID_DIV0S },
    { 0xF00F, 0x2008, CATH_INSTR_ID_TST },
    { 0xF00F, 0x2009, CATH_INSTR_ID_AND },
    { 0xF00F, 0x200A, CATH_INSTR_ID_XOR },
    { 0xF00F, 0x200B, CATH_INSTR_ID_OR },
    { 0xF00F, 0x200C, CATH_INSTR_ID_CMPSTR },
    { 0xF00F, 0x200D, CATH_INSTR_ID_XTRCT },
    { 0xF00F, 0x200E, CATH_INSTR_ID_MULU },
    { 0xF00F, 0x200F, CATH_INSTR_ID_MULS },
    
    // 0011 nnnn mmmm xxxx
    { 0xF00F, 0x3000, CATH_INSTR_ID_CMPEQ },
    { 0xF00F, 0x3002, CATH_INSTR_ID_CMPHS },
    { 0xF00F, 0x3003, CATH_INSTR_ID_CMPGE },
    { 0xF00F, 0x3004, CATH_INSTR_ID_DIV1 },
    { 0xF00F, 0x3005, CATH_INSTR_ID_DMULU },
    { 0xF00F, 0x3006, CATH_INSTR_ID_CMPHI },
    { 0xF00F, 0x3007, CATH_INSTR_ID_CMPGT },
    { 0xF00F, 0x3008, CATH_INSTR_ID_SUB },
    { 0xF00F, 0x300A, CATH_INSTR_ID_SUBC },
    { 0xF00F, 0x300B, CATH_INSTR_ID_SUBV },
    { 0xF00F, 0x300C, CATH_INSTR_ID_ADD },
    { 0xF00F, 0x300D, CATH_INSTR_ID_DMULS },
    { 0xF00F, 0x300E, CATH_INSTR_ID_ADDC },
    { 0xF00F, 0x300F, CATH_INSTR_ID_ADDV },
    
    // 0100 nnnn xxxx xxxx
    { 0xF0FF, 0x402B, CATH_INSTR_ID_JMP },
    { 0xF0FF, 0x400B, CATH_INSTR_ID_JSR },
    { 0xF0FF, 0x4000, CATH_INSTR_ID_SHLL },
    { 0xF0FF, 0x4001, CATH_INSTR_ID_SHLR },
    { 0xF0FF, 0x4008, CATH_INSTR_ID_SHLLN },
    { 0xF0FF, 0x4009, CATH_INSTR_ID_SHLRN },
    { 0xF0FF, 0x4018, CATH_INSTR_ID_SHLLN },
    { 0xF0FF, 0x4019, CATH_INSTR_ID_SHLRN },
    { 0xF0FF, 0x4028, CATH_INSTR_ID_SHLLN },
    { 0xF0FF, 0x4029, CATH_INSTR_ID_SHLRN },
    { 0xF0FF, 0x4010, CATH_INSTR_ID_DT },
    { 0xF0FF, 0x4011, CATH_INSTR_ID_CMPPZ },
    { 0xF0FF, 0x4015, CATH_INSTR_ID_CMPPL },
    { 0xF0FF, 0x4020, CATH_INSTR_ID_SHAL },
    { 0xF0FF, 0x4021, CATH_INSTR_ID_SHAR },
    { 0xF0FF, 0x4024, CATH_INSTR_ID_ROTCL },
    { 0xF0FF, 0x4025, CATH_INSTR_ID_ROTCR },
    { 0xF0FF, 0x4004, CATH_INSTR_ID_ROTL },
    { 0xF0FF, 0x4005, CATH_INSTR_ID_ROTR },
    { 0xF0FF, 0x401E, CATH_INSTR_ID_LDCGBR},
    { 0xF0FF, 0x400E, CATH_INSTR_ID_LDCSR },
    { 0xF0FF, 0x402E, CATH_INSTR_ID_LDCVBR}, 
    { 0xF0FF, 0x400A, CATH_INSTR_ID_LDSMACH },
    { 0xF0FF, 0x401A, CATH_INSTR_ID_LDSMACL },
    { 0xF0FF, 0x4022, CATH_INSTR_ID_STSPRPD },
    { 0xF0FF, 0x402A, CATH_INSTR_ID_LDSPR },
    
    // 0101 nnnn mmmm dddd
    { 0xF000, 0x5000, CATH_INSTR_ID_MOVLL4 },
    
    // 0110 nnnn mmm xxxx
    { 0xF00F, 0x6000, CATH_INSTR_ID_MOVBL },
    { 0xF00F, 0x6001, CATH_INSTR_ID_MOVWL },
    { 0xF00F, 0x6002, CATH_INSTR_ID_MOVLL },
    { 0xF00F, 0x6003, CATH_INSTR_ID_MOV },
    { 0xF00F, 0x6004, CATH_INSTR_ID_MOVBP },
    { 0xF00F, 0x6005, CATH_INSTR_ID_MOVWP },
    { 0xF00F, 0x6006, CATH_INSTR_ID_MOVLP },
    { 0xF00F, 0x6007, CATH_INSTR_ID_NOT },
    { 0xF00F, 0x6008, CATH_INSTR_ID_SWAPB },
    { 0xF00F, 0x6009, CATH_INSTR_ID_SWAPW },
    { 0xF00F, 0x600A, CATH_INSTR_ID_NEGC },
    { 0xF00F, 0x600B, CATH_INSTR_ID_NEG },
    { 0xF00F, 0x600C, CATH_INSTR_ID_EXTUB },
    { 0xF00F, 0x600D, CATH_INSTR_ID_EXTUW },
    { 0xF00F, 0x600E, CATH_INSTR_ID_EXTSB },
    { 0xF00F, 0x600F, CATH_INSTR_ID_EXTSW },
    
    // 0111 nnnn iiii iiii
    { 0xF000, 0x7000, CATH_INSTR_ID_ADDI },
    
    // 1000 xxxx dddd dddd
    { 0xFF00, 0x8400, CATH_INSTR_ID_MOVBL4 },
    { 0xFF00, 0x8500, CATH_INSTR_ID_MOVWL4 },
    { 0xFF00, 0x8900, CATH_INSTR_ID_BT },
    { 0xFF00, 0x8B00, CATH_INSTR_ID_BF },
    { 0xFF00, 0x8D00, CATH_INSTR_ID_BTS },
    { 0xFF00, 0x8F00, CATH_INSTR_ID_BFS },
    
    // 1001 nnnn dddd dddd
    { 0xF000, 0x9000, CATH_INSTR_ID_MOVWLP },
    
    // 1010 dddd dddd dddd
    { 0xF000, 0xA000, CATH_INSTR_ID_BRA },
    
    // 1011 dddd dddd dddd
    { 0xF000, 0xB000, CATH_INSTR_ID_BSR },
    
    // 1100 xxxx iiii iiii
    { 0xFF00, 0xC900, CATH_INSTR_ID_ANDI },
    { 0xFF00, 0xCB00, CATH_INSTR_ID_ORI },
    { 0xFF00, 0xC800, CATH_INSTR_ID_TSTI },
    { 0xFF00, 0xCA00, CATH_INSTR_ID_XORI },
    { 0xFF00, 0xCD00, CATH_INSTR_ID_ANDM },
    { 0xFF00, 0xCF00, CATH_INSTR_ID_ORM },
    { 0xFF00, 0xCC00, CATH_INSTR_ID_TSTM },
    { 0xFF00, 0xCE00, CATH_INSTR_ID_XORM },
    { 0xFF00, 0xC700, CATH_INSTR_ID_MOVA },
    { 0xFF00, 0xC300, CATH_INSTR_ID_TRAPA },
    { 0xFF00, 0x8800, CATH_INSTR_ID_CMPEQI },
    { 0xFF00, 0xC400, CATH_INSTR_ID_MOVBLG },
    { 0xFF00, 0xC500, CATH_INSTR_ID_MOVWLG },
    { 0xFF00, 0xC600, CATH_INSTR_ID_MOVLLG },
    { 0xFF00, 0xC000, CATH_INSTR_ID_MOVBSG },
    { 0xFF00, 0xC100, CATH_INSTR_ID_MOVWSG },
    { 0xFF00, 0xC200, CATH_INSTR_ID_MOVLSG },

    // 1101 nnnn dddd dddd
    { 0xF000, 0xD000, CATH_INSTR_ID_MOVLLP },
    
    // 1110 nnnn iiii iiii
    { 0xF000, 0xE000, CATH_INSTR_ID_MOVI },
    
    { 0, 0, CATH_INSTR_ID_INVALID }
};

// DECODE INSTRUCTION ON THE BASIS OF THEIR RESPECTIVE ID
// AND IDENITIFIERS
//
// THIS IS MADE POSSIBLE THROUGH THE WAYS IN WHICH 
// SEPARATED BITS ARE ACCESSED WITHIN THE MACROS 
static CATH_INSTR_ID CATH_INSTRUCTION_PROCESS_UNIQUE_ID(const SH_INSTRUCTION* INSTR)
{
    U16 WORD = INSTR->WORD;

    // SEARCH THROUGH EVERY RESPECTIVE ENTRY WITHIN THE TABLE
    for(const SH_ENTRY* ENTRY = SH2_DECODE_TABLE; ENTRY->MASK != 0; ENTRY++)
    {
        if((WORD & ENTRY->MASK) == (ENTRY->PATTERN & ENTRY->MASK)) return ENTRY->ID;
    }

    return CATH_INSTR_ID_INVALID;
}

// FINALLY, WE PROCESS THE ENTRY AND AND DETERMINE IF
// THERE IS A CORRESPONDING MATCH
void CATH_INSTRUCTION_PROCESS(SH_INSTRUCTION* INSTR)
{
    // NO VALID INSTRUCTION? 
    if(!INSTR) goto PROCESS_NONE;
    
    // PROCESS THE UNIQUE ID PROVIDED BY THE ID LOOKUP TABLE
    INSTR->INSTR_ID = CATH_INSTRUCTION_PROCESS_UNIQUE_ID(INSTR);

    // THEN DETERMINE THE VALIDITY OF EACH ENTRY OF INSTRUCTIONS
    // IN THE ENUM BASED ON THE DESCRIPTOR TABLE
    INSTR->DESCRIPTOR = (INSTR->INSTR_ID < CATH_INSTR_ID_ALL_MAX) 
        ? &INSTR_DESCRIPTORS[INSTR->INSTR_ID] 
        : &INSTR_DESCRIPTORS[CATH_INSTR_ID_INVALID];

    return;

    PROCESS_NONE:
        fprintf(stderr, "COULDN'T PROCESS INSTRUCTION: %s\n", 
            CATH_GET_OPCODE_NAME(INSTR->INSTR_ID));
}
