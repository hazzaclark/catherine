// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS

// NESTED INCLUDES

#include "instructions/instruction.h"
#include "tables/tables.h"

// INITIALISE THE BASIS FOR THE PROVIDED INSTRUCTION
// ACCESS THE WORD ENCOMPASSING THE INSTRUCTION AND IT'S RESPECTIVE ADDRESS
void CATH_INSTRUCTION_INIT(SH_INSTRUCTION* INSTR, U16 WORD, U32 ADDRESS)
{
    INSTR->WORD = WORD;
    INSTR->BITS = 16;

    INSTR->INSTR_ID = CATH_INSTR_ID_INVALID;
    INSTR->DESCRIPTOR = &INSTR_DESCRIPTORS[INSTR->INSTR_ID];
    INSTR->ID_TYPE = CATH_INSTR_ID_TYPE_INVALID;

    INSTR->PC = ADDRESS;
    INSTR->CATEGORY = CATH_INSTRCAT_SH2;

    INSTR->FLAGS = 0;
}

// GET THE SIGN EXTENDED IMMEDIATE VALUE BASED OFF OF 
// THE CORRESPONDING DESCRIPTOR VALUE
S32 CATH_INSTRUCTION_GET_IMM(const SH_INSTRUCTION* INSTR)
{
    U8 IMM = SH2_INSTR_GET_IMM8(INSTR);

    // CHECK IF THE CURRENT INSTRUCTION USES
    // AN UNSIGNED IDENTIFIER
    if(INSTR->DESCRIPTOR && INSTR->DESCRIPTOR->IS_UNSIGNED) return (S32)IMM;

    // SIGN EXTEND TO 32 BIT AS EVENTUAL RET 
    return (S32)(S8)IMM;
}

// GET THE CURRENT DISPLACEMENT VALUES ASSOCIATED WITH AN INSTRUCTION
S32 CATH_INSTRUCTION_GET_DISP(const SH_INSTRUCTION* INSTR)
{
    // IF WE HAVE NO CORRESPONDING INSTRUCTIONS
    if(INSTR->INSTR_ID >= CATH_INSTR_ID_ALL_MAX) return 0;

     // NOW WE CAN DYNAMICALLY GET THE DISPLACEMENT TYPE AND SCALE
    // BASED ON TABLE GENERATION
    U8 SCALE = CATH_DISP_SCALE[INSTR->INSTR_ID];
    S32 DISP = SH2_INSTR_GET_DISP_SCALE(INSTR, SCALE);

    return DISP * SCALE;
}

// DETERMIN FIRST OF ALL BEFORE DISASSEMBLY IF WE HAVE A CORRESPONDING
// INSTRUCTION WITHIN THE BUFFER
// 
// AFTER WHICH, WE APPLY THE CORRESPONDING FILTERS TO IT AND GET THE 
// RAW INSTRUCTION THEREIN
UNK CATH_INSTRUCTION_DISASM_DATA(const SH_INSTRUCTION* INSTR, char* DEST)
{
    UNK TOTAL_SIZE = 0;
    CATH_BUFFER_CPY(DEST, TOTAL_SIZE, ".short");

    CATH_SPRINTF(DEST, TOTAL_SIZE, " 0x%08X", CATH_GET_RAW(INSTR));
}

// DEFINE THE BASIS BY WHICH WE ARE ABLE TO DISASSEMBLE EACH INSTRUCTION
// THIS FOLLOWS A SIMPLE BASIS OF A FEW STEPS
//
// 1. DO WE HAVE A VALID INSTRUCTION WITHIN THE DATA POOL? (IS IT A VALID WORD?)
// 2. GET THE CURRENT INSTRUCTION NAME AND DETERMINE IT'S READ POSITION
// 3. WRITE OPCODES AND OPERANDS AND RETURN

UNK CATH_INSTRUCTION_DISASM(const SH_INSTRUCTION* INSTR, char* DEST, UNK DEST_SIZE)
{
    // FIRST WE DETERMINE IF WE HAVE A VALID INSTRUCTION
    if(SH2_INSTR_VALID(INSTR))
    {
        // AFTER WHICH, WE DETERMINE THE SIZE OF THE INSTRUCTION
        // AND APPLY IT TO THE BUFFER
        UNK TOTAL_SIZE = 0;
        CATH_BUFFER(DEST, TOTAL_SIZE, CATH_INSTRUCTION_DISASM_DATA(INSTR, DEST));
    }
}
