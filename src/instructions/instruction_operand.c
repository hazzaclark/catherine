// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS

// NESTED INCLUDES

#include "instructions/instruction.h"
#include "tables/tables.h"

// ACCESS THE CURRENT BUFFER SIZE FOR EACH OPERAND
// ASSUME SUCH ON THE BASIS OF THE PROVIDED CALLBACK TO LAISE WITH 
// THE DECLARATIONS OF EACH OPERAND TYPE
UNK CATH_OPERAND_TYPE_GET_BUFFER_SIZE(SH_OPERAND_TYPE TYPE, const SH_INSTRUCTION* INSTR)
{
    // ASSIGN THE CALLBACK TO EACH RESPECTIVE TYPE
    SH2_OPERAND_CALLBACK CB;
    CB = INSTR_CALLBACKS[TYPE];

    return CB(INSTR, NULL, 0);
}

// SIMILAR BUT THIS TIME, ACCESS THE DESTINATION FROM THE CALLBACK
UNK CATH_OPERAND_TYPE_DISASM(SH_OPERAND_TYPE TYPE, const SH_INSTRUCTION* INSTR, char* DEST)
{
    SH2_OPERAND_CALLBACK CB;
    CB = INSTR_CALLBACKS[TYPE];

    return CB(INSTR, DEST, 64);
}

// DETERMINES ALL OF THE CONURRENT OPERANDS AND APPLIES
// THEM TO THE BUFFER
UNK CATH_INSTRUCTION_DISASM_OPERAND(const SH_INSTRUCTION* INSTR, char* DEST)
{
    UNK TOTAL_SIZE = 0;

    for(UNK INDEX = 0; INDEX < CATH_ARRAY(INSTR->DESCRIPTOR->OPERAND_TYPE) && INSTR->DESCRIPTOR->OPERAND_TYPE[INDEX] != OPERAND_NONE; INDEX++)
    {
       // ADD SEPARATOR PADDING BETWEEN OPERANDS
       if(INDEX > 0 && TOTAL_SIZE > 0)
       {
            DEST[TOTAL_SIZE++] = ',';
            DEST[TOTAL_SIZE++] = ' ';
       }

       // AUTOMATICALLY ASSIGN THE SIZE BASED ON WHAT IS BEING DISASSEMBLED
       UNK OPERAND_SIZE = CATH_OPERAND_TYPE_DISASM(INSTR->DESCRIPTOR->OPERAND_TYPE[INDEX], INSTR, DEST + TOTAL_SIZE);
       TOTAL_SIZE += OPERAND_SIZE;
    }

    return TOTAL_SIZE;
}
