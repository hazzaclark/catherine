// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS
//
// SPECIFICALLY, FOCUSSING ON THE INHERITANCE METHODS OF CREATING AN INSTRUCTION BASE
// TYPE FOR THE CURRENT WORD AND ADDRESS

#ifndef CATH_INSTR_SH2_BASE_HPP
#define CATH_INSTR_SH2_BASE_HPP

#pragma once 

// NESTED INCLUDES

#include "instructions/instruction.hpp"

namespace catherine
{    
    using CATH_INSTR_DIR = catherine::CATH_INSTR_ID_CXX;


    class CATH_INSTRUCTION_SH2 : public CATH_INSTRUCTION
    {
        public:
            CATH_INSTRUCTION_SH2(U16 WORD, U32 ADDRESS);
            virtual ~CATH_INSTRUCTION_SH2() = default;
    };

    // HELPER FUNCTIONS MOSTLY TO DO WITH ACCESSING SPECIFIC
    // INSTRUCTION TYPES - SOME NECESSARY FOR THE RECOMPILED BLOCKS

    inline bool CATH_INSTR_IS_RTS(const CATH_INSTRUCTION& INSTR)
    { 
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_RTS;
    }

    inline bool CATH_INSTR_IS_MOVA(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_MOVA;
    }
    
    inline bool CATH_INSTR_IS_BRANCH(CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->IS_BRANCH;
    }

    inline bool CATH_INSTR_IS_JMP(CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->IS_JUMP;
    }

    inline bool CATH_INSTR_HAS_DELAY_SLOT(const CATH_INSTRUCTION& INSTR) 
    {
        return INSTR.CATH_GET_RAW_PTR()->DESCRIPTOR->HAS_DELAY_SLOT;
    }

    inline bool CATH_INSTR_IS_FUNCTION_CALL(const CATH_INSTRUCTION& INSTR)
    {
        CATH_INSTR_DIR ID = INSTR.CATH_GET_UNIQUE_ID();
        return (ID == CATH_INSTR_DIR::CATH_INSTR_ID_BSR     || 
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_BSRF    ||
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_JSR);
    }

    inline bool CATH_INSTR_IS_INDIRECT_JMP(const CATH_INSTRUCTION& INSTR)
    {
        CATH_INSTR_DIR ID = INSTR.CATH_GET_UNIQUE_ID();
        return (ID == CATH_INSTR_DIR::CATH_INSTR_ID_JMP     ||
                ID == CATH_INSTR_DIR::CATH_INSTR_ID_BRAF); 
    }

    // ACCESS THE CURRENT PC VALUE AGAINST IT'S PROVIDED DISPLACEMENT LABEL
    // DISPLACEMENT FOR JUMP CONDITIONS SUPPOSE THE BIT SHIFT ACCOUNTING
    // FOR THAT LENGTH OF THE INSTRUCTION AGAINST AN OFFSET    
    inline U32 CATH_INSTR_GET_JTLB(const CATH_INSTRUCTION& INSTR)
    {
        U32 PC = INSTR.CATH_GET_RAW_PC();
        U8 DISP = INSTR.CATH_GET_DISP8();

        return (PC & ~3U) + 4 + (static_cast<U32>(DISP) * 4);
    }

    // ACCESS THE REQUIRED INDEXXED LOAD FROM THE PROVIDED
    // JTLB INSTRCTION BASE
    inline bool CATH_INSTR_IS_INDEXXED_LOAD(const CATH_INSTRUCTION& INSTR)
    {
        return INSTR.CATH_GET_UNIQUE_ID() == CATH_INSTR_DIR::CATH_INSTR_ID_MOVLL0;
    }

    // DEFINE THE BASIS FOR ACCESSING RELEVANT METHODS
    // ASSOCIATED WITH A PRE-COMPUTED JUMP TABLE
    //
    // WE DO THIS TO BE ABLE TO DETERMINE WHICH
    // SECTIONS ARE CODE AND DATA
    inline bool CATH_IS_JTLB_PATTERN(const CATH_INSTRUCTION& MOV, 
                                    const CATH_INSTRUCTION& LOAD, 
                                    const CATH_INSTRUCTION& JUMP)
    {
        return CATH_INSTR_IS_MOVA(MOV) && 
        CATH_INSTR_IS_INDEXXED_LOAD(LOAD) && CATH_INSTR_IS_INDIRECT_JMP(JUMP);
        
    }
}

#endif
