// COPYRIGHT (C) HARRY CLARK 2025
// HITACHI SUPERH INSTRUCTION DECODER

// THIS FILE PERTAINS TOWARDS THE MODULARISATION AND LAYOUT OF THE INSTRUCTIONS
// IDENTIFIERS, THEIR RESPECTIVE CHARACTERISTICS, THE CONCATENATION OF TYPES
// AND HELPER FUNCTIONS - ALL PERTAINING TOWARDS THE INSTRUCTIONS

// NESTED INCLUDES

#include "instructions/instruction.h"
#include "tables/tables.h"

// INITIALISE THE BASIS FOR THE PROVIDED INSTRUCTION
// ACCESS THE WORD ENCOMPASSING THE INSTRUCTION AND IT'S RESPECTIVE ADDRESS
void CATH_INSTRUCTION_INIT(SH_INSTRUCTION* INSTR, U16 WORD, U32 ADDRESS)
{
    INSTR->WORD = WORD;
    INSTR->BITS = 16;

    INSTR->DESCRIPTOR = &INSTR_DESCRIPTORS[INSTR->INSTR_ID];
    INSTR->INSTR_ID = CATH_INSTR_ID_INVALID;
    INSTR->ID_TYPE = CATH_INSTR_ID_TYPE_INVALID;

    INSTR->PC = ADDRESS;
    INSTR->CATEGORY = CATH_INSTRCAT_SH2;

    INSTR->FLAGS = 0;
}

// GET THE SIGN EXTENDED IMMEDIATE VALUE BASED OFF OF 
// THE CORRESPONDING DESCRIPTOR VALUE
S32 CATH_INSTRUCTION_GET_IMM(const SH_INSTRUCTION* INSTR)
{
    U8 IMM = SH2_INSTR_GET_IMM8(INSTR);

    // CHECK IF THE CURRENT INSTRUCTION USES
    // AN UNSIGNED IDENTIFIER
    if(INSTR->DESCRIPTOR && INSTR->DESCRIPTOR->IS_UNSIGNED) return (S32)IMM;

    // SIGN EXTEND TO 32 BIT AS EVENTUAL RET 
    return (S32)(S8)IMM;
}

S32 CATH_INSTRUCTION_GET_DISP(const SH_INSTRUCTION* INSTR)
{
    // IF WE HAVE NO CORRESPONDING INSTRUCTIONS
    if(INSTR->INSTR_ID >= CATH_INSTR_ID_ALL_MAX) return 0;

    S32 DISP = 0;
    U8 SCALE = CATH_DISP_SCALE[INSTR->INSTR_ID];
    
    // EXTRACT DISPLACEMENT BASED ON TYPE
    // THIS SWITCH IS HERE TO MITIGATE CERTAIN
    // INSTRUCTIONS THAT WOULD REQUIRE SPECIFIC DISPLACMENET
    // 
    // IT SHOULD BE MENTIONED THAT THE BRANCH_OFFSET
    // INLINE STILL USES THE DISP ENTRY TABLE TO
    // DYNAMICALLY HANDLE STATIC DISPLACEMENT 
    switch(INSTR->INSTR_ID)
    {
        case CATH_INSTR_ID_BRA:
        case CATH_INSTR_ID_BSR:
        {
            U16 DISP12 = SH2_INSTR_GET_DISP12(INSTR);
            DISP = ((S32)(S16)DISP12 & SH2_INSTR_DISP_SIGN_BIT) ? (S32)(DISP12 | SH2_INSTR_DISP_SIGN_MASK) : (S32)DISP12;
            break;
        }
        
        case CATH_INSTR_ID_BT:
        case CATH_INSTR_ID_BF:
        case CATH_INSTR_ID_BTS:
        case CATH_INSTR_ID_BFS:
        {
            U8 DISP8 = SH2_INSTR_GET_DISP8(INSTR);
            DISP = (S32)(S8)DISP8;  
            break;
        }
        
        case CATH_INSTR_ID_MOVLL4:
        case CATH_INSTR_ID_MOVLS4:
        case CATH_INSTR_ID_MOVWL4:
        {
            DISP = (S32)SH2_INSTR_GET_DISP4(INSTR);
            break;
        }
        
        case CATH_INSTR_ID_MOVA:
        case CATH_INSTR_ID_MOVLLP:
        case CATH_INSTR_ID_MOVWLP:
        case CATH_INSTR_ID_MOVBLG:
        case CATH_INSTR_ID_MOVWLG:
        case CATH_INSTR_ID_MOVLLG:
        case CATH_INSTR_ID_MOVBSG:
        case CATH_INSTR_ID_MOVWSG:
        case CATH_INSTR_ID_MOVLSG:
        {
            DISP = (S32)SH2_INSTR_GET_DISP8(INSTR); 
            break;
        }
        
        default:
            DISP = 0;
            break;
    }

    // NOW RETURN THE SCALE DYNAMICALLY AGAINST THE
    // TABLE ENTIRES
    return DISP * SCALE;
}

// DETERMINE FIRST OF ALL BEFORE DISASSEMBLY IF WE HAVE A CORRESPONDING
// INSTRUCTION WITHIN THE BUFFER
// 
// AFTER WHICH, WE APPLY THE CORRESPONDING FILTERS TO IT AND GET THE 
// RAW INSTRUCTION THEREIN
UNK CATH_INSTRUCTION_DISASM_DATA(const SH_INSTRUCTION* INSTR, char* DEST)
{
    // LEVERAGE USING STDLIB RATHER THAN TRYING TO BE SMART
    // WITH MANUAL BUFFER ALLOC
    if(DEST == NULL)
    {
        return snprintf(NULL, 0, "0x%04x ", CATH_GET_RAW(INSTR));
    }

    // OTHERWISE, WRITE SAFELY TO BUFFER 
    // DOING SO LIKE THIS NEGATES THE ENTIRE
    // NEED FOR DEFINING SIZE UNSAFELY
    return sprintf(DEST, "0x%04x ", CATH_GET_RAW(INSTR));
}

// NOW WE DETERMINE THE SIZE OF THE CURRENT INSUTRCTION
UNK CATH_INSTRUCTION_GET_SIZE(const SH_INSTRUCTION* INSTR)
{
    // DETERMINE THE LENGTH OF THE CURRENT OPCODE AND ASSIGN IT'S SIZE
    UNK TOTAL_SIZE = 0;
    UNK OPCODE_LENGTH = strlen(CATH_GET_OPCODE_NAME(INSTR->INSTR_ID));

    TOTAL_SIZE += OPCODE_LENGTH;

    // WHAT IF THERE ARE NO OPERANDS?
    if(INSTR->DESCRIPTOR->OPERAND_TYPE[0] == OPERAND_NONE) return TOTAL_SIZE;

    // NOW WE CAN PROPERLY ASSIGN THE PROPER SIZE
    return TOTAL_SIZE;
}

// DEFINE THE BASIS FOR DISASSEMBLING PER INSTRUCTION
// ACHIEVED BY ACCESSING THE CURRENT OPCODE NAME AND COPYING
// IT OT THE BUFFER
UNK CATH_INSTRUCTION_DISASM_INSTR(const SH_INSTRUCTION* INSTR, char* DEST)
{
    UNK TOTAL_SIZE = 0;
    const char* RAW_INSTR = CATH_GET_OPCODE_NAME(INSTR->INSTR_ID);
    UNK INSTR_LENGTH = strlen(RAW_INSTR);

    // COPY THE CURRENT OPCODE INTO THE BUFFER BASED ON THE 
    // SIZE OF IT'S MASK
    if(DEST != NULL)
    {
        memcpy(DEST, RAW_INSTR, INSTR_LENGTH);
        DEST += INSTR_LENGTH;
    }

    TOTAL_SIZE += INSTR_LENGTH;

    // CHECK IF WE HAVE ANY VALID OPERANDS FOR THE PROVIDED INSTRUCTION
    // INSIDE THIS, WE WANT TO BE ABLE TO ACCOUNT FOR NULL TERMS
    // FOR ALL CORRESPONDENCE
    if(INSTR->DESCRIPTOR->OPERAND_TYPE[0] != OPERAND_NONE)
    {
        if(DEST != NULL)
        {
            *DEST = ' ';
            DEST++;
        }

        TOTAL_SIZE++;

        // NOW DO THE SAME FOR THE SIZE OF THE OPERAND
        // WITHIN A RELEVANT INSTRUCTION
        UNK OPERAND_SIZE = CATH_INSTRUCTION_DISASM_OPERAND(INSTR, DEST);
        if(DEST != NULL)
        {
            DEST += OPERAND_SIZE;
        }

        TOTAL_SIZE += OPERAND_SIZE;
    }
    
    // 23/01/26 
    // MADE SURE TO CATCH NULL CHECK BEFOREHAND
    if(DEST != NULL)
    {
        *DEST = '\0';
    }

    return TOTAL_SIZE;
}

// DEFINE THE BASIS BY WHICH WE ARE ABLE TO DISASSEMBLE EACH INSTRUCTION
// THIS FOLLOWS A SIMPLE BASIS OF A FEW STEPS
//
// 1. DO WE HAVE A VALID INSTRUCTION WITHIN THE DATA POOL? (IS IT A VALID WORD?)
// 2. GET THE CURRENT INSTRUCTION NAME AND DETERMINE IT'S READ POSITION
// 3. WRITE OPCODES AND OPERANDS AND RETURN

UNK CATH_INSTRUCTION_DISASM(const SH_INSTRUCTION* INSTR, char* DEST)
{
    UNK TOTAL_SIZE = 0;
    char* BUFFER_WRITE = DEST;

    // REFACTORED TO HANDLE SAFE WRITES AS OPPOSED TO 
    // MANUAL BUFFER HANDLING
    //
    // FIRST WE DETERMINE IF WE HAVE A VALID INSTRUCTION
    if(SH2_INSTR_VALID(INSTR))
    {
        // WRITE THE CONTENTS OF THE RAW INSTRUCTION
        // AFTER WHICH, WE DETERMINE THE SIZE OF THE INSTRUCTION
        // AND APPLY IT TO THE BUFFER
        UNK DATA = CATH_INSTRUCTION_DISASM_DATA(INSTR, BUFFER_WRITE);

        if(BUFFER_WRITE != NULL) { BUFFER_WRITE += DATA; }

        TOTAL_SIZE += DATA;
    }

    UNK INSTR_SIZE = CATH_INSTRUCTION_DISASM_INSTR(INSTR, BUFFER_WRITE);
    TOTAL_SIZE += INSTR_SIZE;

    return TOTAL_SIZE;
}
